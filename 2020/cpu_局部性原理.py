__doc__ = """
CPU 缓存分为数据缓存与指令缓存，
对于数据缓存，我们应在循环体中尽量操作同一块内存上的数据，由于缓存是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时也有性能提升。
对于指令缓存，有规律的条件分支能够让 CPU 的分支预测发挥作用，进一步提升执行效率。对于多核系统，如果进程的缓存命中率非常高，则可以考虑绑定 CPU 来提升缓存命中率。
-- 摘自 《极客时间》

python的列表是否满足cpu的局部性原理?
"""

n = 10000
two_array = [[0 for x in range(n)] for y in range(n)]
i = 0


def test1():
    """横向遍历"""
    i = 0
    while i < n:
        # print("i:", i)
        j = 0
        while j < n:
            # print("j:", j)
            two_array[i][j] = 1
            j += 1
        i += 1
    # print(two_array)


def test2():
    """纵向遍历"""
    i = 0
    while i < n:
        # print("i:", i)
        j = 0
        while j < n:
            # print("j:", j)
            two_array[j][i] = 1
            j += 1
        i += 1
    # print(two_array)


if __name__ == "__main__":
    from timeit import Timer

    t1 = Timer("test1()", "from __main__ import test1")
    print(t1.timeit(1))  # 8.988574638

    t2 = Timer("test2()", "from __main__ import test2")
    print(t2.timeit(1))  # 15.018176900999999

# 基本可以验证,python的列表也是满足cpu的局部性原理的

"""
局部性分类
　　局部性有两种基本的分类， 时间局部性 和 空间局部性 ，按Wikipedia的资料，可以分为以下五类，其实有些就是时间局部性和空间局部性的特殊情况。

时间局部性(Temporal locality):
　　如果某个信息这次被访问，那它有可能在不久的未来被多次访问。时间局部性是空间局部性访问地址一样时的一种特殊情况。这种情况下，可以把常用的数据加cache来优化访存。

空间局部性(Spatial locality):
　　如果某个位置的信息被访问，那和它相邻的信息也很有可能被访问到。 这个也很好理解，我们大部分情况下代码都是顺序执行，数据也是顺序访问的。

内存局部性(Memory locality):
访问内存时，大概率会访问连续的块，而不是单一的内存地址，其实就是空间局部性在内存上的体现。目前计算机设计中，都是以块/页为单位管理调度存储，其实就是在利用空间局部性来优化性能。

分支局部性(Branch locality)
　　这个又被称为顺序局部性，计算机中大部分指令是顺序执行，顺序执行和非顺序执行的比例大致是5:1，即便有if这种选择分支，其实大多数情况下某个分支都是被大概率选中的，于是就有了CPU的分支预测优化。

等距局部性(Equidistant locality)
　　等距局部性是指如果某个位置被访问，那和它相邻等距离的连续地址极有可能会被访问到，它位于空间局部性和分支局部性之间。 举个例子，比如多个相同格式的数据数组，你只取其中每个数据的一部分字段，那么他们可能在内存中地址距离是等距的，这个可以通过简单的线性预测就预测是未来访问的位置。

"""
