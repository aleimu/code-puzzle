"""
>>  #右移
<<  #左移
|   #位或
&   #位与
^   #位异或
~   #非
"""

# 十进制转二级制/八进制/十六进制
bin(10)
oct(10)
hex(10)
# 十进制转二进制：bin(10) --> '0b1010'   tpye:是字符串类型 0b：表示2进制
# 十进制转八进制：oct(10) --> '0o12'     tpye:是字符串类型 0o：表示8进制
# 十进制转十六进制：hex(10) --> '0xa'    tpye:是字符串类型 0x：表示16进制

# 几种将字符串形式的二进制转成十进制的方式
int('0b100', 2)
int(b'0b100', 2)
int('100', 2)

read = b'1'  # bytes
write = b'2'
run = b'4'

print(read)

print(4 << 2)

a, b, c = 0b1, 0b10, 0b100
print(a, b, c)  # 1 2 4
print(int('0b1', 2), int('0b10', 2), int('0b100', 2))  # 1 2 4
print(bin(1), bin(2), bin(4), )  # 0b1 0b10 0b100
print(b + c)  # 6
print(bin(2) + bin(4))  # 0b100b100
print(type(bin(2)))  # str

# 二进制操作在权限校验
PUBLIC_ARTICLE = 1  # 发行文章
CREATE_ARTICLE = 2  # 添加文章
MODIFY_ARTICLE = 4  # 修改文章
DELETE_ARTICLE = 8  # 删除文章
SHARCH_ARTICLE = 16  # 搜索文章
CREATE_COMMENT = 32  # 添加文章评论
DELETE_COMMENT = 64  # 删除文章评论
# 权限位        删除文章评论      添加文章评论        搜索文章         删除文章            修改文章          添加文章          发行文章
final_allow = DELETE_COMMENT | CREATE_COMMENT | SHARCH_ARTICLE | DELETE_ARTICLE | MODIFY_ARTICLE | CREATE_ARTICLE | PUBLIC_ARTICLE
# 假设一个人有这几种权限: DELETE_COMMENT SHARCH_ARTICLE MODIFY_ARTICLE CREATE_ARTICLE
some_one = DELETE_COMMENT | SHARCH_ARTICLE | MODIFY_ARTICLE | CREATE_ARTICLE
# 当我们想要校验他有没有某些权限的时候就可以这样,若结果是校验的权限值那就表名有此权限,为0则表示没有权限
print(some_one & DELETE_COMMENT)  # 0
print(some_one & DELETE_ARTICLE)  # 64

# 延伸阅读 位图（BitMap）, 布隆过滤器（Bloom Filter）
"""
1 byte = 8 bits （1字节B=8比特），1KB=1024 B, 1 MB = 1024 KB, 1GB=1024 MB

BitMap 位图法的所占空间随集合内最大元素的增大而增大。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，
比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。空间复杂度随集合内最大元素增大而线性增大。

BloomFilter 是由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的。布隆过滤器可以用于检索一个元素是否在一个集合中。
它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。
布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，false positive rate(误报率)越大，但是false negative (漏报)是不可能的。
布隆过滤器判断为【数据存在】 可能数据并不存在，但是如果判断为【数据不存在】那么数据就一定是不存在的。
常见的补救办法是在建立白名单，存储那些可能被误判的元素。

Redis中bitmap的几个使用场景:
1.用户签到
2.统计活跃用户
3.用户在线状态



布隆过滤器（Bloom Filter）的几个使用场景:
1.解决缓存穿透的问题
一般情况下，先查询缓存是否有该条数据，缓存中没有时，再查询数据库。
当数据库也不存在该条数据时，每次查询都要访问数据库，这就是缓存穿透。
缓存穿透带来的问题是，当有大量请求查询数据库不存在的数据时，就会给数据库带来压力，甚至会拖垮数据库。
可以使用布隆过滤器解决缓存穿透的问题，把已存在数据的key存在布隆过滤器中。
当有新的请求时，先到布隆过滤器中查询是否存在，如果不存在该条数据直接返回；如果存在该条数据再查询缓存查询数据库。

2.黑名单校验
一个网站有 100 亿 url 存在一个黑名单中，每条 url 平均 64 字节。这个黑名单要怎么存？
若此时随便输入一个 url，你如何快速判断该 url 是否在这个黑名单中？
发现存在黑名单中的，就执行特定操作。比如：识别垃圾邮件，只要是邮箱在黑名单中的邮件，就识别为垃圾邮件。
假设黑名单的数量是数以亿计的，存放起来就是非常耗费存储空间的，布隆过滤器则是一个较好的解决方案。
把所有黑名单都放在布隆过滤器中，再收到邮件时，判断邮件地址是否在布隆过滤器中即可。

数据库防止穿库, Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。  
业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。  
缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。  
WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。
Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务  
Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。  
SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。
"""

"""
HyperLogLog
Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。
伯努利试验
统计 APP或网页 的一个页面，每天有多少用户点击进入的次数。同一个用户的反复点击进入记为 1 次。


"""