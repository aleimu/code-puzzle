一面
1.	http状态码/header/请求方法, 哪些请求方法是幂等的
    
    方法名	作用	安全性	幂等性
    DELETE	删除资源，幂等操作	否	是
    POST	新增资源，非幂等操作	否	否
    GET	查询资源，幂等操作	是	是
    PUT　	更新资源，幂等操作	否	是
    PATCH	更新资源，非幂等操作	否	否
    HEAD	 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头	是	是
    OPTIONS	 用于客户端查看服务器的性能	是	是
    如果一个方法重复执行多次，产生的效果是一样的，那么这个方法就是幂等的。

2. https加密原理

    http存在三个弊端：
    
    1）无法保证消息的保密性；
    2）无法保证消息的完整性和准确性；
    3）无法保证消息来源的可靠性。
    
    认证机构,加密技术,数字证书,数字签名
    加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。
    非对称加密需要通过证书和权威机构来验证公钥的合法性。
    HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。
    
3. python协程原理/缺点
    python2: yield + send（利用生成器实现协程） 
    python3: asyncio + async/await asyncio.get_event_loop事件循环
    可以中断的函数,用户态线程,由用户维护协程的中断和让渡,协程是工作在线程基础上的,依然无法使用多核性能.
    
    I/O为瓶颈的程序正是协程所擅长的：
    多任务并发（非并行），每个任务在合适的时候挂起（发起I/O）和恢复(I/O结束).对于类似爬虫这种延时的IO操作，协程是个大利器，优点很多
    ，他可以在一个阻塞发生时，挂起当前程序，跑去执行其他程序，把事件注册到循环中，实现多程序并发。
    协程优势:
    最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
    第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
    因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
 
4. python GIL, 为什么有GIL 还需要threading
5. python gevent协程调度原理/缺点

    from gevent import monkey; monkey.patch_all()
    Gevent是一个基于Greenlet实现的网络库，通过greenlet实现协程。基本思想是一个greenlet就认为是一个协程，
    当一个greenlet遇到IO操作的时候，比如访问网络，就会自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。
    由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO操作。
    Greenlet是作为一个C扩展模块，它封装了libevent事件循环的API，可以让开发者在不改变编程习惯的同时，用同步的方式写异步IO的代码。
    Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。
    
6. 设计一个文本编辑器实现插入/删除/查询
7. 头条文章向用户推送避免重复推送的问题

8. 工作中遇到的印象深刻的问题
9，两个单链表求和
10，两种存储引擎
11，http的返回码
12，mysql 索引
    主键索引是聚集索引,其他索引是非聚集索引
    主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚集索引（clustered index）。
    非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）
    innodb引擎，索引和数据放在一个文件里面
    myisam引擎，索引和数据放在不同文件
    
    B+树,适合结构化数据查询,支持join
    es 倒排索引 (正排索引:id对应一串字符串, 倒排索引:字符串分词,每个单词对应多个id),适合非机构化数据,适合全文索引

13，链表操作(在线写代码)
14，http状态码
    
    1**	信息，服务器收到请求，需要请求者继续执行操作
    2**	成功，操作被成功接收并处理
    3**	重定向，需要进一步的操作以完成请求
    4**	客户端错误，请求包含语法错误或无法完成请求
    5**	服务器错误，服务器在处理请求的过程中发生了错误
    
15，UDP / TCP 协议

    TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。
    
            UDP	     TCP
    是否连接	无连接	面向连接
    是否可靠	不可靠传输，不使用流量控制和拥塞控制	可靠传输，使用流量控制和拥塞控制
    连接对象个数	支持一对一，一对多，多对一和多对多交互通信	只能是一对一通信
    传输方式	面向报文	面向字节流
    首部开销	首部开销小，仅8字节	首部最小20字节，最大60字节
    适用场景	适用于实时应用（IP电话、视频会议、直播等）	适用于要求可靠传输的应用，例如文件传输
    
    
16，链表操作 [手写代码]
17，乐观锁 / 悲观锁
18，三次握手
19， Socket
20，Hbase 底层原理
21，Map 底层原理
    
    开放寻址法中，所有的元素都存放在散列表里，当产生哈希冲突时，通过一个探测函数计算出下一个候选位置，如果下一个获选位置还是有冲突，
    那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。
    
    数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
    数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。
    
    在Python3.6之前，字典是无序的，但是Python3.7+，字典是有序的。
    Python3.6之前的无序字典:
    计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（DictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的enteies哈希表中的下标位置
    若index下标位置已经被占用，则会判断enteies的key是否与要插入的key是否相等
    如果key相等就表示key已存在，则更新value值
    如果key不相等，就表示hash冲突，则会继续向下寻找空位置，一直到找到剩余空位为止。
    
    Python3.7+后的新的实现方式:
    计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（IndicesDictMinSize） - 1】，运算后会得到一个数字【index】，
    这个index就是要插入的indices的下标位置（注：具体算法与Python版本相关，并不一定一样）
    得到index后，会找到indices的位置，但是此位置不是存的hash值，而是存的len(enteies)，表示该值在enteies中的位置
    如果出现hash冲突，则处理方式与老字典处理方式类似
    新字典存储数据本身的enteies并不会稀疏，由indices来维护具体存储的位置，enteies中的数据是和插入的数据是一样的，所以新的字典是有序的。
    
    Python字典的key可以使用字符串（str），整型（int），元祖（tuple）等。我们已经知道，字典是通过哈希算法来计算key的值，所以key必须为可哈希的，
    list不能作为字典的key，因为list是可变的及不可哈希的对象，所以不能作为字典的key。
    python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容拷贝到新数组中。接近 2/3 时，数组就会扩容。
    
    哈希冲突的解决方法:链接法,开放寻址法
    
        
22，数据库分表 / 分库 / 集群
22.给定一个二叉树，返回二叉树每层的最左的值。
23.手里有一副扑克牌。按照下列规则吧他堆放桌上。一，拿出最上面的一张牌，放桌上，然后把接下来的一张牌放在扑克牌的最下面。循环，直到没有手牌。现在已知桌上牌的顺序。求原手牌的顺序。
24.redis内存不足，如何解决
25. mysql索引的使用和原理
26. epoll和poll,select的区别
27.实现一个有顺序的LinkedList，实现deleteAll(int val)方法删除所有值为val的节点，和save(int val)方法添加一个值为val的节点。
28.线程池的工作流程。线程的几种状态，什么情况会进入阻塞
29.JDK基础 集合 锁 
30.Mysql的索引结构 聚簇索引
31限流。限流算法。令牌桶的不足
32.GC CMS，CMS的参数
33.JVM的一些排查工具jstat, jstack ,jmap
34.工作中遇到的问题如何排查
35.一排盒子，每个盒子上标了能走的最大步数，从第一个盒子开始，判断能否走到最后的盒子
36..栈，增加一个max方法；
37..自己设计hash；
38.微博限定用户每次输入最多140个字符，用户如果传字符串很长的链接，怎么办
39. 输入一串空格分开的整数，相邻不会重复如：1 2 4 3 5，只返回其中一个峰值就可以，比如返回 4 或者 5
峰值定义：大于相邻两个数字就是峰值；对于头尾两个数字，分别大于相邻的一个数字即算峰值
40.二叉树镜像
41.两个线程，一个只能存有数组1、2、3和另一个存有a、b、c，然后通过调度，最终结果输出1a2b3c
42..输入一个int数组，返回一个数组，其中奇数都在左边，偶数都在右边
附加条件 不使用额外的空间
43.java多线程知识点，如synchronized，reentrantLock以及两者比较
44.java线程池，submit跟execute的区别
45.stack实现一个min方法，O(1)的复杂度
46.数据库两种引擎比较
47.数据库3个字段的联合索引，在用单字段时能否命中索引
48.数据库如何建索引，和如何分库分表
49.找到一个文件里出现次数最多的的数字，文件大小远大于内存容量
50.10G文件1G内存，
51.打印重复数字
52.查找前topK
53. 给一个数组和一个整数，输出数组中所有和为给定整数的元素下标
54. MySQL两种存储引擎的差异；
55. where a>1 and b>1;where a = 1; where b = 2,如何为这种条件语句建立索引；
56. LRU的实现
57. 介绍一个项目中遇到的问题。 
58. 一个100G的文件，内存只有8G，如何给文件排序，文件内容都是按行存储的URL
59. a.产品设计过程中面对的挑战和难点；b、周围同事对我的评价；c、产品设计考虑的几个点
60. .k路归并排序           
61.lru原理要非常详细的数据结果和过程结构       
62.给个数组，只有重复的，求所有和为21的下标:不用n2的暴力算法，要考虑数字相同的下标，先说思路没问   题才能共享屏幕写
63. 根据二叉树前序遍历生成avl树
64. 编程题：string转double
65、hashmap实现方式
66、数据库事务、隔离级别
其他就是聊的他的项目了
67 、out Of memory Error 跟 stack Over flow Error 的比较
（可能单词没拼对）
68、数据库的隔离级别
69、java 的 array 跟 list的比较，底层原理上的
70、有sql的编程题，是问每门课程都大于80分的学生名字
71、java编程题，a、反转一句英语的所有单词：hello world - > world hello
                              b、6 7 8 9 0 1 2 3 4 5，找一个数
72、还有tcp，三次握手；ssl。
73、对称性加密跟非对称性加密的比较，使用场景
74、数据库事务
75、java的多线程
76、涉及面好广 还有密码学的，加密算法RSA
77、搜索引擎倒排原理及实现方式
78、Redis高可用方案
79、主键与索引的联系和区别
80、索引的实现方式，为什么会采用这种数据结构
81、Redis缓存删除策略
82、编码实现LRU算法
83、统计大量访问日志（分几百M 和 几百G的场景）；得出访问次数最多的前K个人 （单台机器实现）
84. 给你一个连续素数数组 让你找出增长比第k小的位置
85. 代码题：有序数组 A = [1, 2, 2, 3, 3, 5, 5, 5]，b = 5，在A中找出b的序号的上下界，考察思路和代码熟练度

86.自我介绍、项目经历（会结合你的项目经历即兴问一些相关联的问题，以设计思路，框架性的思考为主）
   HTTPS原理
   Oracle MySQL特性、优劣势
   Redis等前沿技术栈的知识面
87. python的装饰器
     mysql的innodb与myisam区别，索引
   .  10G文件，1G内存，找出最大的K个数，找出重复数
88. 简单的一道系统设计题：用redis做限流
    然后是Mysql各种基础知识
    然后是HTTP状态码 502/504
    然后是一道系统设计题：微信扫码登录

84.杭州后台；删除链表中重复的结点
在一个排序的链表中，存在重复的结
点，请删除该链表中重复的结点，重复
的结点不保留，返回链表头指针。例
如，链表1－＞2－＞3－＞3－＞4－4－＞5处理后为
1->2->5
总结:比较注重CS修养、底层源码实现 
85. 杭州后台一面二面：
1、ctrl c过程； 退出当前 session 所有前台进程并对系统发送SIGINT信号,系统收到SIGINT信号后，会把 CPU 时间交由内核态，然后再进行退出程序，挂起，恢复，或自定义操作。
2、去除重复列表；
3、单链表求和；

select
count(case when score between 400 and 500 then 1 end) as 400到500,
count(case when score between 300 and 400 then 1 end) as 300到400
from student_info;


二面：
1：多个人玩贪吃蛇设计 
2：项目开发性设计，自己设计，自己定规则
3.B B+ 跳表区别 时间复杂度
4.Https与http区别， tls的加密流程
5.自增ID与uuid的优劣
6.Redis的事务以及实现方式
7.给定字符串的全排列
8. 介绍经历、java线程池基础知识、自己实现一个线程池，然后是二叉树的bfs，最小公共子串得长度，最大不重复子串的长度
9.dubbo的容错机制有哪些、负载均衡机制有哪些
10.fail-fast
11. 45.一个有序数组，求一个数出现的次数
12. 数据库索引：表有3列a,b,c，需支持查询（a,b）(b) (b,c)，索引如何建
13.反转二叉树
14.数据库表（id, name, parentId）如何组装成树?
15. 主键索引和非主键索引的区别
16. 数据库事务的隔离级别
17. redis和memcached
18. 数据库查询优化
19. 编程题，贪心算法
20.不同字符最大子串
根据给定的输入字符串，返回包含有最多
k个不同字符的子字符串的长度及子字符
串在输入字符串的起始下标如果有多个
符合条件的子字符串，则返回第一个子字
符串的下标
输入描述
输入为一个待校验的字符串
输出描述
两个数字，分表表示子字符串的长度以及子字符串首字符在输入字符串的下标

三面 ：
1.leetcode 670，然后系统设计题，设计群消息已读功能，
三面应该是1道算法1道系统设计

2、假设是一个抽奖的游戏，不同的人是有不同的概率倍数，是一个整数，例如1、3、5...
输入100万人，要求抽奖抽出来2万个人；并且假设每个人都有一个唯一id

3.写一个函数做下抽奖，输入和输出的数据结构自己设计
4、然后就是项目上的一些东西  redis 高可用怎么实现、 redis过期怎么实现、Mysql索引的注意事项
5 code review
6.数据库索引+前缀匹配
7.缓存设计
8.并发控制（乐观锁，悲观锁）
9.xss && csfr
10. 杭州后台三面：推送的频率控制，   

抖音评论列表的设计及缓存实现，

    在详细体验了抖音的评论系统之后，发现有以下特点:
    
    1.视频作者的评论优先显示
    2.关注的人的评论优先显示
    3.其余评论按照时间倒序显示
    两张表设计，comment，评论信息表，reply 回复信息表
    我认为是对评论id进行缓存，

    1.作者对本视频回复，那么可以缓存作者的评论id。
    2.好友优先显示，可缓存每个用户对每个视频的评论id，这一步实际上可以吧作者缓存这个干掉了
    3.按评论id逆序。
    4，如高赞回答，就需要独立对视频高赞维护一个list。
    
    评论表的设计如下：

    表字段	字段说明
    id	主键
    topic_id	主题ID
    topic_type	主题type
    content	评论内容
    from_uid	评论用户id
    like        点赞数
    dislike     反对数
    
    回复表的设计如下：

    表字段	字段说明
    id	主键
    comment_id	评论ID
    reply_id	回复目标id
    reply_type	回复类型
    content	回复内容
    from_uid	回复用户id
    to_uid	目标用户id
    
    优化的方式也有很多:

    分库分表。分库分表是最为常用也最有效的优化方式，建议按照主题来分库分表。这样同一个主题下面的评论就会落到同一张表里，避免了跨表查询。
    
    适当的数据冗余。如果你需要显示评论人的相关信息，那么在插入评论时就把这些信息写入评论表中，避免多次查询。实际上，如果是纪录数据，都可以冗余对应的数据信息，因为它们的数据的实时行和一致性要求并不高，用户不会因为评论中的头像没更新而撕了你，哈哈。
    
    附加幂等数据只允许单项操作。如果pd要求你能给评论点赞，那么你可以告诉他只能点赞，不能取消。因为从幂等性的要求来说，每个赞都是一条记录。评论的赞数如果都从点赞表中统计得出，那么性能开销会十分巨大，而且点赞如此轻量级的一个操作一定会加剧点赞表的竞争操作。所以建议直接在评论表中添加一个like_count的计数器，该字段只增不减。热门评论加缓存。类似于网易新闻的热门评论，读取频度非常高，可以专门开接口给客户端，同时该接口做缓存。
    
MySQL索引怎么建、http头、http header
11. sizeof运算符计算要考虑哪些因素
     函数定义int a[100000]可能出现什么问题
     一百万个用户抽奖，奖品只有1000个，每人最多中奖一次，每个用户中奖倍率不一样，给出代码实现。
12. 1.     问了redis数据结构和实现
      2.     问hashmap
      3.     浅拷贝深拷贝实现
      4.     把一面的算法题再做一次
13. 项目聊很多（使用的中间件实现原理）
     带权重抽奖代码实现
     类加载过程
     热加载、热替换
     jvm参数：-server -client
    JIT即时编译原理
    排查线上问题经历、思路
    聊部门情况
