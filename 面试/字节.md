# [面试题网页版](https://www.cnblogs.com/wyp1988/p/12070850.html)

一面
1.	http状态码/header/请求方法, 哪些请求方法是幂等的
    
    方法名	作用	安全性	幂等性
    DELETE	删除资源，幂等操作	否	是
    POST	新增资源，非幂等操作	否	否
    GET	查询资源，幂等操作	是	是
    PUT　	更新资源，幂等操作	否	是
    PATCH	更新资源，非幂等操作	否	否
    HEAD	 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头	是	是
    OPTIONS	 用于客户端查看服务器的性能	是	是
    如果一个方法重复执行多次，产生的效果是一样的，那么这个方法就是幂等的。

2. https加密原理

    http存在三个弊端：
    
    1）无法保证消息的保密性；
    2）无法保证消息的完整性和准确性；
    3）无法保证消息来源的可靠性。
    
    认证机构,加密技术,数字证书,数字签名
    加密分对称加密和非对称加密。对称加密效率高，但是解决不了密钥传输问题；非对称加密可以解决这个问题，但是效率不高。
    非对称加密需要通过证书和权威机构来验证公钥的合法性。
    HTTPS 是综合了对称加密和非对称加密算法的 HTTP 协议。既保证传输安全，也保证传输效率。
    
3. python协程原理/缺点
    python2: yield + send（利用生成器实现协程） 
    python3: asyncio + async/await asyncio.get_event_loop事件循环
    可以中断的函数,用户态线程,由用户维护协程的中断和让渡,协程是工作在线程基础上的,依然无法使用多核性能.
    
    I/O为瓶颈的程序正是协程所擅长的：
    多任务并发（非并行），每个任务在合适的时候挂起（发起I/O）和恢复(I/O结束).对于类似爬虫这种延时的IO操作，协程是个大利器，优点很多
    ，他可以在一个阻塞发生时，挂起当前程序，跑去执行其他程序，把事件注册到循环中，实现多程序并发。
    协程优势:
    最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
    第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
    因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
 
4. python GIL, 为什么有GIL 还需要threading
5. python gevent协程调度原理/缺点

    from gevent import monkey; monkey.patch_all()
    Gevent是一个基于Greenlet实现的网络库，通过greenlet实现协程。基本思想是一个greenlet就认为是一个协程，
    当一个greenlet遇到IO操作的时候，比如访问网络，就会自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。
    由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO操作。
    Greenlet是作为一个C扩展模块，它封装了libevent事件循环的API，可以让开发者在不改变编程习惯的同时，用同步的方式写异步IO的代码。
    Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。
    
6. 设计一个文本编辑器实现插入/删除/查询
7. 头条文章向用户推送避免重复推送的问题

8. 工作中遇到的印象深刻的问题
9，两个单链表求和
10，两种存储引擎
11，http的返回码
12，mysql 索引
    主键索引是聚集索引,其他索引是非聚集索引
    主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚集索引（clustered index）。
    非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）
    innodb引擎，索引和数据放在一个文件里面
    myisam引擎，索引和数据放在不同文件
    
    B+树,适合结构化数据查询,支持join
    es 倒排索引 (正排索引:id对应一串字符串, 倒排索引:字符串分词,每个单词对应多个id),适合非机构化数据,适合全文索引

13，链表操作(在线写代码)
14，http状态码
    
    1**	信息，服务器收到请求，需要请求者继续执行操作
    2**	成功，操作被成功接收并处理
    3**	重定向，需要进一步的操作以完成请求
    4**	客户端错误，请求包含语法错误或无法完成请求
    5**	服务器错误，服务器在处理请求的过程中发生了错误
    
15，UDP / TCP 协议

    TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。
    
            UDP	     TCP
    是否连接	无连接	面向连接
    是否可靠	不可靠传输，不使用流量控制和拥塞控制	可靠传输，使用流量控制和拥塞控制
    连接对象个数	支持一对一，一对多，多对一和多对多交互通信	只能是一对一通信
    传输方式	面向报文	面向字节流
    首部开销	首部开销小，仅8字节	首部最小20字节，最大60字节
    适用场景	适用于实时应用（IP电话、视频会议、直播等）	适用于要求可靠传输的应用，例如文件传输
    
    
16，链表操作 [手写代码]
17，乐观锁 / 悲观锁
18，三次握手
19， Socket
20，Hbase 底层原理
21，Map 底层原理
    
    开放寻址法中，所有的元素都存放在散列表里，当产生哈希冲突时，通过一个探测函数计算出下一个候选位置，如果下一个获选位置还是有冲突，
    那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素。
    
    数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
    数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。
    
    在Python3.6之前，字典是无序的，但是Python3.7+，字典是有序的。
    Python3.6之前的无序字典:
    计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（DictMinSize） - 1】，运算后会得到一个数字【index】，这个index就是要插入的enteies哈希表中的下标位置
    若index下标位置已经被占用，则会判断enteies的key是否与要插入的key是否相等
    如果key相等就表示key已存在，则更新value值
    如果key不相等，就表示hash冲突，则会继续向下寻找空位置，一直到找到剩余空位为止。
    
    Python3.7+后的新的实现方式:
    计算key的hash值【hash(key)】，再和mask做与操作【mask=字典最小长度（IndicesDictMinSize） - 1】，运算后会得到一个数字【index】，
    这个index就是要插入的indices的下标位置（注：具体算法与Python版本相关，并不一定一样）
    得到index后，会找到indices的位置，但是此位置不是存的hash值，而是存的len(enteies)，表示该值在enteies中的位置
    如果出现hash冲突，则处理方式与老字典处理方式类似
    新字典存储数据本身的enteies并不会稀疏，由indices来维护具体存储的位置，enteies中的数据是和插入的数据是一样的，所以新的字典是有序的。
    
    Python字典的key可以使用字符串（str），整型（int），元祖（tuple）等。我们已经知道，字典是通过哈希算法来计算key的值，所以key必须为可哈希的，
    list不能作为字典的key，因为list是可变的及不可哈希的对象，所以不能作为字典的key。
    python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容拷贝到新数组中。接近 2/3 时，数组就会扩容。
    
    哈希冲突的解决方法:链接法,开放寻址法
    
        
22，数据库分表 / 分库 / 集群
22.给定一个二叉树，返回二叉树每层的最左的值。
23.手里有一副扑克牌。按照下列规则吧他堆放桌上。一，拿出最上面的一张牌，放桌上，然后把接下来的一张牌放在扑克牌的最下面。循环，直到没有手牌。现在已知桌上牌的顺序。求原手牌的顺序。
24.redis内存不足，如何解决
```
Redis缓存删除策略 & redis内存不足，如何解决
被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key
注：被动删除：只有key被操作时(如GET)，REDIS才会被动检查该key是否过期，如果过期则删除之并且返回NIL。
主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key
过期的
Redis会周期性的随机测试一批设置了过期时间的key并进行处理。测试到的已过期的key将被删除。
如果没有设置时间，那缓存就是永不过期
如果设置了过期时间，之后又想让缓存永不过期，使用persist key
redis过期怎么实现
Redis过期策略---实现原理
三种过期策略
定时删除：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
懒汉式删除：key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期，则删除，返回null（用的时候再检查删除）。
定期删除：每隔一段时间执行一次删除过期key操作
内存满了时
Redis是基于内存的key-value数据库，因为系统的内存大小有限，所以我们在使用Redis的时候可以配置Redis能使用的最大的内存大小。
通过在Redis安装目录下面的redis.conf配置文件中添加以下配置设置内存大小：maxmemory 100mb
Redis支持运行时通过命令动态修改内存大小：config set maxmemory 100mb
Redis的内存淘汰（当前已用内存超过maxmemory限定时，触发主动清理策略）
Redis内存满了的解决办法
既然可以设置Redis最大占用内存大小，那么配置的内存就有用完的时候。那在内存用完的时候，还继续往Redis里面添加数据不就没内存可用了吗？
LRU：表示最近最少使用； LFU：表示最不常用的
实际上Redis定义了几种策略用来处理这种情况：
noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰
allkeys-lru：从所有key中使用LRU算法进行淘汰
volatile-lfu 筛选出设置了有效期的，最不常用的 key；
allkeys-lfu 所有 key 中，筛选出最不常用的 key ；
allkeys-random：从所有key中随机淘汰数据
volatile-random：从设置了过期时间的key中随机淘汰
volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰
当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。
通过配置文件设置淘汰策略（修改redis.conf文件）：maxmemory-policy allkeys-lru
通过命令修改淘汰策略：config set maxmemory-policy allkeys-lru
Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。可以通过maxmemory-samples参数修改采样数量：例：maxmemory-samples 10
Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。
LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是Least Frequently Used，它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。
```
25. mysql索引的使用和原理
26. epoll和poll,select的区别
27.实现一个有顺序的LinkedList，实现deleteAll(int val)方法删除所有值为val的节点，和save(int val)方法添加一个值为val的节点。
28.线程池的工作流程。线程的几种状态，什么情况会进入阻塞
29.JDK基础 集合 锁 
30.Mysql的索引结构 聚簇索引
31限流。限流算法。令牌桶的不足
32.GC CMS，CMS的参数
33.JVM的一些排查工具jstat, jstack ,jmap
34.工作中遇到的问题如何排查
35.一排盒子，每个盒子上标了能走的最大步数，从第一个盒子开始，判断能否走到最后的盒子
36..栈，增加一个max方法；
37..自己设计hash；
38.微博限定用户每次输入最多140个字符，用户如果传字符串很长的链接，怎么办
39. 输入一串空格分开的整数，相邻不会重复如：1 2 4 3 5，只返回其中一个峰值就可以，比如返回 4 或者 5
峰值定义：大于相邻两个数字就是峰值；对于头尾两个数字，分别大于相邻的一个数字即算峰值
40.二叉树镜像
41.两个线程，一个只能存有数组1、2、3和另一个存有a、b、c，然后通过调度，最终结果输出1a2b3c
42..输入一个int数组，返回一个数组，其中奇数都在左边，偶数都在右边
附加条件 不使用额外的空间
43.java多线程知识点，如synchronized，reentrantLock以及两者比较
44.java线程池，submit跟execute的区别
45.stack实现一个min方法，O(1)的复杂度
46.数据库两种引擎比较
47.数据库3个字段的联合索引，在用单字段时能否命中索引
48.数据库如何建索引，和如何分库分表
49.找到一个文件里出现次数最多的的数字，文件大小远大于内存容量
50.10G文件1G内存，
51.打印重复数字
52.查找前topK
53. 给一个数组和一个整数，输出数组中所有和为给定整数的元素下标
54. MySQL两种存储引擎的差异；
55. where a>1 and b>1;where a = 1; where b = 2,如何为这种条件语句建立索引；
56. LRU的实现
57. 介绍一个项目中遇到的问题。 
58. 一个100G的文件，内存只有8G，如何给文件排序，文件内容都是按行存储的URL
59. a.产品设计过程中面对的挑战和难点；b、周围同事对我的评价；c、产品设计考虑的几个点
60. .k路归并排序           
61.lru原理要非常详细的数据结果和过程结构       
62.给个数组，只有重复的，求所有和为21的下标:不用n2的暴力算法，要考虑数字相同的下标，先说思路没问   题才能共享屏幕写
63. 根据二叉树前序遍历生成avl树
64. 编程题：string转double
65、hashmap实现方式
66、数据库事务、隔离级别
其他就是聊的他的项目了
67 、out Of memory Error 跟 stack Over flow Error 的比较
（可能单词没拼对）
68、数据库的隔离级别
69、java 的 array 跟 list的比较，底层原理上的
70、有sql的编程题，是问每门课程都大于80分的学生名字
71、java编程题，a、反转一句英语的所有单词：hello world - > world hello
                              b、6 7 8 9 0 1 2 3 4 5，找一个数
72、还有tcp，三次握手；ssl。
73、对称性加密跟非对称性加密的比较，使用场景
74、数据库事务
75、java的多线程
76、涉及面好广 还有密码学的，加密算法RSA
77、搜索引擎倒排原理及实现方式
78、Redis高可用方案
79、主键与索引的联系和区别
80、索引的实现方式，为什么会采用这种数据结构
81、Redis缓存删除策略
82、编码实现LRU算法
83、统计大量访问日志（分几百M 和 几百G的场景）；得出访问次数最多的前K个人 （单台机器实现）
```
100G 数据，按照 100M 内存拆分，然后排序有序的数据，然后写入到 file1,file2…file100。

多路归并。

第一回合：

从 file1,file2,file3……file100.取出第一个数。及最小的。所有的初始指针都是第一行。

min1=min(min1=min(fil1,file2,file3……file100)；file2,file3……file100)；min1 写入到大数据文件。大数据行数指针+1。min1对应的行数指针+1。第二回合：从file1,file2,file3……file100.取出第一个数。及最小的。所有的初始指针都是第一行。min1对应的行数指针+1。

第二回合：从file1,file2,file3……file100.取出第一个数。及最小的。所有的初始指针都是第一行。min2 = min(fil1,fil1,file2,file3……file100)；

min2写入到大数据文件。大数据行数指针+1。min2写入到大数据文件。大数据行数指针+1。min2 对应的行数指针+1。

。。。
```

84. 给你一个连续素数数组 让你找出增长比第k小的位置
85. 代码题：有序数组 A = [1, 2, 2, 3, 3, 5, 5, 5]，b = 5，在A中找出b的序号的上下界，考察思路和代码熟练度

86.自我介绍、项目经历（会结合你的项目经历即兴问一些相关联的问题，以设计思路，框架性的思考为主）
   HTTPS原理
   Oracle MySQL特性、优劣势
   Redis等前沿技术栈的知识面
87. python的装饰器
     mysql的innodb与myisam区别，索引
   .  10G文件，1G内存，找出最大的K个数，找出重复数
88. 简单的一道系统设计题：用redis做限流
    然后是Mysql各种基础知识
    然后是HTTP状态码 502/504
    然后是一道系统设计题：微信扫码登录

84.杭州后台；删除链表中重复的结点
在一个排序的链表中，存在重复的结
点，请删除该链表中重复的结点，重复
的结点不保留，返回链表头指针。例
如，链表1－＞2－＞3－＞3－＞4－4－＞5处理后为
1->2->5
总结:比较注重CS修养、底层源码实现 
85. 杭州后台一面二面：
1、ctrl c过程； 退出当前 session 所有前台进程并对系统发送SIGINT信号,系统收到SIGINT信号后，会把 CPU 时间交由内核态，然后再进行退出程序，挂起，恢复，或自定义操作。
2、去除重复列表；
3、单链表求和；

select
count(case when score between 400 and 500 then 1 end) as 400到500,
count(case when score between 300 and 400 then 1 end) as 300到400
from student_info;


二面：
1：多个人玩贪吃蛇设计 
2：项目开发性设计，自己设计，自己定规则
3.B B+ 跳表区别 时间复杂度
4.Https与http区别， tls的加密流程
5.自增ID与uuid的优劣
6.Redis的事务以及实现方式
7.给定字符串的全排列
8. 介绍经历、java线程池基础知识、自己实现一个线程池，然后是二叉树的bfs，最小公共子串得长度，最大不重复子串的长度
9.dubbo的容错机制有哪些、负载均衡机制有哪些
10.fail-fast
11. 45.一个有序数组，求一个数出现的次数
12. 数据库索引：表有3列a,b,c，需支持查询（a,b）(b) (b,c)，索引如何建
13.反转二叉树
14.数据库表（id, name, parentId）如何组装成树?
15. 主键索引和非主键索引的区别
16. 数据库事务的隔离级别
17. redis和memcached
18. 数据库查询优化
19. 编程题，贪心算法
20.不同字符最大子串
根据给定的输入字符串，返回包含有最多
k个不同字符的子字符串的长度及子字符
串在输入字符串的起始下标如果有多个
符合条件的子字符串，则返回第一个子字
符串的下标
输入描述
输入为一个待校验的字符串
输出描述
两个数字，分表表示子字符串的长度以及子字符串首字符在输入字符串的下标

三面 ：
1.leetcode 670，然后系统设计题，设计群消息已读功能，
三面应该是1道算法1道系统设计

2、假设是一个抽奖的游戏，不同的人是有不同的概率倍数，是一个整数，例如1、3、5...
输入100万人，要求抽奖抽出来2万个人；并且假设每个人都有一个唯一id

3.写一个函数做下抽奖，输入和输出的数据结构自己设计
4、然后就是项目上的一些东西  redis 高可用怎么实现、 redis过期怎么实现、Mysql索引的注意事项
5 code review
6.数据库索引+前缀匹配
7.缓存设计
8.并发控制（乐观锁，悲观锁）
9.xss && csfr
10. 杭州后台三面：推送的频率控制，   

抖音评论列表的设计及缓存实现，

    在详细体验了抖音的评论系统之后，发现有以下特点:
    
    1.视频作者的评论优先显示
    2.关注的人的评论优先显示
    3.其余评论按照时间倒序显示
    两张表设计，comment，评论信息表，reply 回复信息表
    我认为是对评论id进行缓存，

    1.作者对本视频回复，那么可以缓存作者的评论id。
    2.好友优先显示，可缓存每个用户对每个视频的评论id，这一步实际上可以吧作者缓存这个干掉了
    3.按评论id逆序。
    4，如高赞回答，就需要独立对视频高赞维护一个list。
    
    评论表的设计如下：

    表字段	字段说明
    id	主键
    topic_id	主题ID
    topic_type	主题type
    content	评论内容
    from_uid	评论用户id
    like        点赞数
    dislike     反对数
    
    回复表的设计如下：

    表字段	字段说明
    id	主键
    comment_id	评论ID
    reply_id	回复目标id
    reply_type	回复类型
    content	回复内容
    from_uid	回复用户id
    to_uid	目标用户id
    
    优化的方式也有很多:

    分库分表。分库分表是最为常用也最有效的优化方式，建议按照主题来分库分表。这样同一个主题下面的评论就会落到同一张表里，避免了跨表查询。
    
    适当的数据冗余。如果你需要显示评论人的相关信息，那么在插入评论时就把这些信息写入评论表中，避免多次查询。实际上，如果是纪录数据，都可以冗余对应的数据信息，因为它们的数据的实时行和一致性要求并不高，用户不会因为评论中的头像没更新而撕了你，哈哈。
    
    附加幂等数据只允许单项操作。如果pd要求你能给评论点赞，那么你可以告诉他只能点赞，不能取消。因为从幂等性的要求来说，每个赞都是一条记录。评论的赞数如果都从点赞表中统计得出，那么性能开销会十分巨大，而且点赞如此轻量级的一个操作一定会加剧点赞表的竞争操作。所以建议直接在评论表中添加一个like_count的计数器，该字段只增不减。热门评论加缓存。类似于网易新闻的热门评论，读取频度非常高，可以专门开接口给客户端，同时该接口做缓存。
    
MySQL索引怎么建、http头、http header
11. sizeof运算符计算要考虑哪些因素
     函数定义int a[100000]可能出现什么问题
     一百万个用户抽奖，奖品只有1000个，每人最多中奖一次，每个用户中奖倍率不一样，给出代码实现。
12.   1.     问了redis数据结构和实现
      2.     问hashmap
      3.     浅拷贝深拷贝实现   
             首先深拷贝和浅拷贝都是对象的拷贝，都会生成一个看起来相同的对象，他们本质的区别是拷贝出来的对象的地址是否和原对象一样，也就是地址的复制还是值的复制的区别。
             直接赋值：其实就是对象的引用（别名）。id(变量)是一样的.
             浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。id(变量)不一样.
             深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。id(变量)不一样.
      4.     把一面的算法题再做一次
      
13. 项目聊很多（使用的中间件实现原理）
     带权重抽奖代码实现
     类加载过程
     热加载、热替换
     jvm参数：-server -client
    JIT即时编译原理
    排查线上问题经历、思路
    聊部门情况

一个完整的 HTTP 请求会涉及到哪些协议？
域名解析
浏览器搜索自己的DNS缓存，缓存中维护一张域名与IP地址的对应表；
若没有，则搜索操作系统的DNS缓存；
若没有，则操作系统将域名发送至本地域名服务器（递归查询方式），本地域名服务器查询自己的DNS缓存，查找成功则返回结果，否则，通过以下方式迭代查找：
本地域名服务器向根域名服务器发起请求，根域名服务器返回com域的顶级域名服务器的地址；
本地域名服务器向com域的顶级域名服务器发起请求，返回权限域名服务器地址；
本地域名服务器向权限域名服务器发起请求，得到IP地址；
本地域名服务器将得到的IP地址返回给操作系统，同时自己将IP地址缓存起来；
操作系统将IP地址返回给浏览器，同时自己也将IP地址缓存起来；
至此，浏览器已经得到了域名对应的IP地址。
发起http请求
传输层，选择传输协议，TCP或者UDP，TCP是可靠的传输控制协议，对HTTP请求进行封装，加入了端口号等信息。发起TCP的3次握手（底层在局域网还有arp等）建立TCP连接。
网络层，通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；
数据链路层，把网络层交下来的IP数据报添加首部和尾部，封装为MAC帧，现在根据目的mac开始建立TCP连接，三次握手，接收端在收到物理层上交的比特流后，根据首尾的标记，识别帧的开始和结束，将中间的数据部分上交给网络层，然后层层向上传递到应用层；
服务器端响应http请求，浏览器得到html代码
浏览器解析html代码，并请求html代码中的资源
浏览器对页面进行渲染呈现给用户。

python 垃圾回收:采用引用计算机制为主，标记——清除和分代收集两种机制为辅的策略。
https://www.cnblogs.com/xiugeng/p/10514101.html
https://www.cnblogs.com/libochou/p/10150048.html
1.引用计数
    引用计数机制的缺点：
        1、维护引用计数消耗资源
        2、循环引用,导致内存泄露,Python的引用计数算法不能够处理互相指向自己的对象。

        ```python
        list1=[1,2,3]
        list2=[4,5,6]
        list1.append(list2)
        #list1
        [1, 2, 3, [4, 5, 6]]
        list2.append(list1)
        #list1
        [1, 2, 3, [4, 5, 6, [...]]]
        #list2
        [4, 5, 6, [1, 2, 3, [...]]]
        ```
        
2.标记清除
分为两个阶段：
第一阶段是标记阶段，GC会把所有的『活动对象』打上标记
第二阶段是把那些没有标记的对象『非活动对象』进行回收。
对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。
标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等可能造成循环引用的类型

3.分代回收
分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象


