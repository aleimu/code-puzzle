### 秒杀问题

使用redis做减库存、下单，如何保证这两步操作的要么都成功要么都失败?
目前得知redis的事务是弱事务并不能保证

1.
redis 减库存可以通过lua 脚本实现，先比较库存是否为0，然后减一，lua脚本 redis保证原子性，
lua脚本的事务，这是redis保证的，lua脚本中错误，是指异常么？redis面对tps 2000的秒杀没有问题啊，随着tps的增大，redis内存很容易占满，
消费队列不及时会导致响应变慢，还得根据业务场景来定啊

2.
lua脚本，里面实现 减库存，把订单写在redis列表里面，之后多线程去list取值，入库成功，清除列表相应的数据，redis保证lua脚本的事务

3.多线程去list取值,pop是原子性的，即使很高的并发，同时有很多用户访问，也是排队一个一个解决（并行转串行）。

用redis还是不合适做事务。根据之前我们这里压测mysql单条记录update的性能大概是500/s如果性能不能满足需求的话有两种思路，
1、是采用redis ，但是库存修改和下单分为两个步骤，库存扣除成功后在执行下单操作，如果下单失败再对库存进行冲正。同时增加对帐机制，对库存和订单进行核对，保证数据的最终一致性
2、采用mysql保证事务，但是对库存进行拆分，通过一拆多来达到增大并发的目的，对同一商品id通过映射函数映射到某一条库存记录，之后在该条库存记录和订单上做事务。
不过这种方式需要自己设计库存的均衡化、以及最后库存不足时候的库存汇集算法


1，调用 incrby ，此时返回数字为减少后的数字。
2，如果此时返回小于 0，返回库存不足。否则就成功获取到库存。(小于0后,是否应该再加1回去)
3，如果用户下单失败，需要用 lua 脚本操作。内容为判断库存是否小于 0 ，小于 0 时直接将新库存 set 进去，否则还是用 incr 自增。要加库存也是用这个脚本的逻辑。

脚本内容如下：
```
local nowNum = redis.call("get","STOCK_KEY")
if (nowNum == nil or nowNum < 0) then
    redis.call("set","STOCK_KEY",INCR)
    return INCR
end
return redis.call("incrby","STOCK_KEY",INCR)
```
