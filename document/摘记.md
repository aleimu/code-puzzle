# 故事的公式: -1.迷茫; 0.意外;1.找到目标;2.阻碍;3.努力;4.结果;5.意外;6.转弯;7.结局

    PRS结构: 1.problem 阐述问题,2.reason 分析原因,3.solution 提出解决方案.
    
    ORS结构: 1.说明目的（Order）2.列举原因（Reason）3.希望支持（Reason）.
    
    否新高: 1.否定现存观点或者方案,2.提出新观点或者方案,3.站在更高的层次去论证.
    
    赶过猪: 指感恩,过去和祝愿,先是感谢被邀请发言,回顾过去,以及祝愿美好的未来.

查理芒格是多元思维模型最早的提倡者，他说这样的好晶体，至少能数出一百个，它们都来自「重要学科的重要结论」，在那本著名的《穷查理宝典》中，他尤其强调了：

    数学：复利原理、排列组合原理、费马帕斯卡系统
    统计学：高斯分布
    物理学：平衡、临界质量
    生物学：进化论、复杂适应系统
    工程学：后备系统，断裂点理论
    社会科学：自我组织理论、层创进化理论、艾尔法罗预测模型
    心理学：误判心理学

斯坦诺维奇也给我们开了一个清单，列出了他认为最重要的五类晶体知识：

    概率推理
    决策科学知识
    科学推理知识
    逻辑的一致性与有效性原则
    经济思维



「通过例子，才能重塑大脑」。奥苏贝尔也强调：起固着作用概念的稳定性和清晰度是我们学习新知识的关键。

    what-why-how，黄金圈法则
    因为黄金圈让你打通人、事、物最本质的三种逻辑
    
    为什么——因果逻辑
    怎么做——先后逻辑
    做什么——主次逻辑


how&what：

    1、如何想通why:
    
    丰田佐吉5why分析法：连续问5次为什么，通常能找出问题的根源。
    笛卡尔坐标：4个角度权衡利弊（命题、否命题、逆命题、逆否命题）。

    2、如何想通how:
    3A原则：（吃得到availability、吃得起affordability、容易吃acceptability）符合才做。
    
    3、如何想通what:

二八法则：做那20%能决定80%结果的事

时间管理四象限：（把20%资源和时间花在1象限，把80%花在2象限）

    救火，重要且紧急，不得不做
    质量，重要但不紧急，决定未来
    蒙蔽，不重要但很紧急，刷存在感
    浪费，不重要且不紧急，浪费生命

说好的市场经济靠倒闭淘汰不优秀的企业，结果是死完最后一个印度人之前大英绝不投降。
究竟是共产主义中, 大锅饭下混日子不干事的人多
还是在资本主义中, 996 的高压下摸鱼消极反抗的人多
在个人思想觉悟高度没有上升到人人有责人人负责前,

各尽所能、按需分配原则

知识总量 + （做事流程 x 个人经验） = 你的专业程度
做50%工作的人 = sqrt(参与该工作的所有人数) 

2%的优化创造98%的价值

刻意练习
对比反馈
微小改进


「对比反馈」是我所知道的终极学习方法之一，核心原理是，通过对比，让最明显的80%消失了，相似的部分不重要。剩下的20%极具含金量，要练就练这部分，否则就是低水平重复。

「手段与目的合一」导致的工具理性是西方思想家对资本主义批判最多的地方。

递归，分治算法，动态规划，贪心算法



进程是分配系统资源的最小单位，线程(带有时间片的函数)是系统调度的最小单位。进程包含线程，线程所属于进程。
进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。
进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。
线程的调度与切换比进程快很多。
协程是一种比线程更加轻量级的存在，最重要的是，协程不被操作系统内核管理，协程是完全由程序控制的。

程序员应该坚持自己的良质，不能因为产品经理或老板而改变一些非常好的做事方法，很多问题都是可以通过沟通解决的，面对复杂的需求工期又特别短，不妨听下陈皓老师（网名：左耳朵耗子）的方法：不要说不，而是给对方选择：

    1、我可以加班加点完成，但是我不保证好的质量，有 bug 你得认，而且事后你要给我 1 个月的时间还债。
    2、我可以加班加点，还能保证质量，但我没办法完成这么多需求，能不能减少一些？
    3、我可以保质保量地完成所有的需求，但是，能不能多给我 2 周时间？

这两天学到了王争的专栏《设计模式之美》，其中提到的如何发现代码质量问题，可以从以下几个方面审视代码：

    1.目录设置是否合理、模块划分是否清晰、代码结构是否满足"高内聚、松耦合"？
    2.是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？
    3.设计模式是否应用得当？是否有过度设计？
    4.代码是否容易扩展？如果要添加新功能，是否容易实现？
    5.代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
    6.代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？
    7.代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

以上是一些通用的关注点，可以作为常规检查项，套用在任何代码的重构上。除此之外，我们还要关注代码实现是否满足业务本身特有的功能和非功能需求。还有一些比较有共性的问题，如下所示。

    1.代码是否实现了预期的业务需求？
    2.逻辑是否正确？是否处理了各种异常情况？
    3.日志打印是否得当？是否方便 debug 排查问题？
    4.接口是否易用？是否支持幂等、事务等？
    5.代码是否存在并发问题？是否线程安全？
    6.性能是否有优化空间，比如，SQL、算法是否可以优化？
    7.是否有安全漏洞？比如输入输出校验是否全面？


日常遇到的大部分问题，大致可以归到如下几类：

    逻辑缺陷：e.g. NPE、死循环、边界情况未覆盖。
    性能瓶颈：e.g. 接口 RT 陡增、吞吐率上不去。
    内存异常：e.g. GC 卡顿、频繁 FGC、内存泄露、OOM
    并发/分布式：e.g. 存在竞争条件、时钟不同步。
    数据问题：e.g. 出现脏数据、序列化失败。
    安全问题：e.g. DDoS 攻击、数据泄露。
    环境故障：e.g. 宿主机宕机、网络不通、丢包。
    操作失误：e.g. 配置推错、删库跑路（危险动作，请勿尝试..）。


pip3 install html5lib
pip3 install matplotlib
pip3 install echarts-countries-pypkg
pip3 install echarts-china-provinces-pypkg
pip3 install echarts-themes-pypkg
jupyter notebook


```go
package main

import (
    "fmt"
)

type tryFunc func()
type catchFunc func(interface{})

// 建立一個模仿 try&catch 的函式供稍後使用
func Try(try tryFunc, catch catchFunc) {
    // 這不會馬上被執行，但當 panic 被執行就會結束程式，結束程式就必定會呼叫 defer
    defer func() {
        // 透過 recover 來從 panic 狀態中恢復，並呼叫捕捉函式
        if err := recover(); err != nil {
            catch(err)
        }
    }()
    // 執行可能帶有 panic 的程式
    try()
}

func main() {
    Try(func() {
        panic("1") //报错之后不会下一步
        panic("2")
    }, func(a interface{}) {
        fmt.Println(a)
    })
}
```



CPU是不会直接和硬盘对话的，他们之间有个中间人，叫DMA（Direct Memory Access）芯片.
CPU计算文件地址  -> 委派DMA读取文件 -> DMA接管总线 -> CPU的A进程阻塞挂起 -> CPU切换到B进程 -> DMA读完文件后通知CPU（一个中断异常）-> CPU切换回A进程操作文件

python3.exe D:\Python38\Tools\scripts\2to3.py -w .\树.py

# 为什么单线程这么快？

Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的性能瓶颈是机器的内存大小、以及网络的带宽
如果使用多线程的话会有线程上下文的切换。对于内存系统来说，单线程操作内存的效率才是最高的。
Redis使用了epoll IO多路复用，可以实现用一条线程处理并发的网络请求

# RDB持久化的详细过程:

Redis会通过系统调用fork()出一个子进程，父子进程是会共享内存的，父进程和子进程共享的这块内存就是在执行fork操作那个时刻的内存快照。由linux的copy on write机制将父子进程共享的这块内存标记为只读状态。
此时对子进程来说，它的任务就是将这块只读内存中的数据保存成RDB文件。
对父进程来说它是有可能收到写命令的，当父进程尝试往这个加了只读状态的内存地址写入数据时，就会触发保护异常，执行linux的 copy on write，也就是将原来内存对应的数据页复制出来一份后，然后对这个副本进行修改。


# AOF持久化
Append Only File，他也是Redis的持久化策略。即将所有的写命令都以日志的方式追加记录下来（只追加，不修改），恢复的时候将这个文件中的命令读出来回放。



# 数据结构与算法

## 数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）。

顺序存储：逻辑上相邻的元素存储在物理位置相邻的存储单元中
链式存储：在数据元素中添加一些地址域或辅助结构，用于存放数据元素之间的关系

```
线性结构：数据元素之间存在一对一的关系
树形结构：数据元素之间存在一对多的关系
图形结构：数据元素之间存在多对多的关系
集合结构：数据元素属于同一个集合
```

比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。

「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。

了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。

综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表，二者的优缺点如下：

数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。


## 数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改。

```
线性就是 for/while 迭代为代表，非线性就是递归为代表。
数组遍历框架，典型的线性迭代结构
链表遍历框架，兼具迭代和递归结构
```

## 二叉树遍历框架，典型的非线性递归遍历结构,因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。


我们在使用计算机解决产问题的过程可以分为下面五个步骤：

    问题的理解：搞清楚问题的输入、要求和输出。
    数据结构设计：设计能处理问题中数据的数据结构，还要设计能支持算法策略的数据结构。
    算法设计：选择算法策略，用适当的方式描述和逐步细化算法步骤。
    算法分析：发现有优化的地方，返回第二步，重新设计数据结构和算法.
    程序实现：用计算机编程，定义数据结构，编写代码实现，并高度和运行。


那我们比较一下 Recursion 和 DP：

Recursion 是从大到小，层层分解，直到 base case 分解不了了再组合返回上去；
DP 是从小到大，记好笔记，不断进步。也就是 Recursion + Cache = DP

# MySQL 的"utf8mb4"才是真正的"UTF-8"。



# docker

https://juejin.im/post/6876019186351964168

## 对比点	虚拟机	docker

    启动速度	需要硬件自检、内核引导、用户空间初始化，慢	非常快
    复杂度	虽然是一个进程，但是难以理解，非常复杂	就是一个进程
    资源占用	众多内核进程产生额外消耗	无多余消耗
    隔离性	强	弱

当你运行一个镜像时，docker 会为这个容器创建 namespace 以及 CGroup。namespace 提供了资源隔离能力，任何运行在容器内的进程看不到宿主机上运行的其他进程，同时对它们影响很小。
namespace 是内核的功能，它用来隔离操作系统的各种资源。相比于虚拟机的资源隔离，namespace 轻量太多。也正是因为它和 CGroup 的存在，容器的使用才成为了一种可能。
namespace 的六项隔离看似全面，实际上依旧没有完全隔离 Linux 的资源，比如 SELinux、 Cgroups 以及 /sys、/proc/sys、/dev/sd* 等目录下的资源。

在容器中 pid 为 1 的进程，在宿主机上只是一个普通的进程,容器中由pid=1产生的其他进程在宿主机上也能看到他们是父子进程.
```
# docker run -it --name busybox --rm busybox /bin/sh
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    6 root      0:00 ps
# docker inspect --format "{{.State.Pid}}" busybox
41881
```

docker 包装了程序的本身以及它的依赖，但是它的运行依赖于 Linux 内核，因为它的所有镜像都是基于 Linux 环境。
虽然 Windows 和 Mac 上都提供了 docker 的安装包，但是都是通过虚拟机的方式完成的，这一点需要注意。


## 容器之间通信的主要方式
    1.通过容器ip访问
        容器重启后，ip会发生变化。通过容器ip访问不是一个好的方案。
    2.通过宿主机的ip:port访问
        通过宿主机的ip:port访问，只能依靠监听在暴露出的端口的进程来进行有限的通信。
    3.通过link建立连接（官方不推荐使用）
        运行容器时，指定参数link，使得源容器与被链接的容器可以进行相互通信，并且接受的容器可以获得源容器的一些数据，比如：环境变量。
    4.通过 User-defined networks（推荐）
        docker network来创建一个桥接网络，在docker run的时候将容器指定到新创建的桥接网络中，这样同一桥接网络中的容器就可以通过互相访问。
        创建网络
        docker network create test-network
        启动容器时，加入创建的网络
        docker run -it --network test-network --network-alias mysql  -e MYSQL_ROOT_PASSWORD=123 mysql:5.7
        启动被链接的容器
        docker run -it --network test-network --network-alias centos  centos /bin/bash


# mqtt与mq

mqtt 与 MQ 的区别：

    mqtt：一种通信协议，类似人类交谈中的汉语、英语、俄语中的一种语言规范
    MQ：一种通信通道，也叫消息队列，类似人类交谈中的用电话、email、微信的一种通信方式
    json：一种内容格式，类似人类交谈中的排比句等方式

MQ实现有很多，如阿里自研并开源RocketMQ，还有类似RabbitMQ、ActiveMQ，他们不管支持MQTT协议，还支持如AMQP、stomp协议等等，EMQ 使用的协议是mqtt。
Mqtt是应用层协议，rabbitmq是基于amqp协议开发的消息代理。

MQTT在MQ上添加的十大优势:

    1.精简，不添加可有可无的功能。以发布/订阅（Pub/Sub）模式为中心，方便消息在传感器之间传递。
    2.把传输量降到最低以提高传输效率。因为MQTT协议的头很小。
    3.MQTT提供层级主题:
    4.MQTT提供多个QoS选项（exact once、at least once、at most once）
    5.MQTT代理加上了对WebSockets的支持，可以方便地实现如下场景：显示设备的实时信息,接收报警等推送信息,查看设备的历史消息
    6.MQTT提供了多个层次的安全特性：
    9.MQTT为开发者提供了大量的回调函数，实时的可以监控当前状态,可以对发生的事件进行及时的应对。
    10.对于只需要建立一次连接，发送大量数据的情况，MQTT提供了simple方法供开发者调用。

